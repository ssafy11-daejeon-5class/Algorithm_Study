## 개미(boj_10158)

- 예상 외로 시간 초과 문제를 해결하기에 난감했던 문제
    - 의외로(?) java version을 낮춰서 시간 초과 문제를 해결…
    - 시간복잡도 측면에서는 더이상 줄일 수 있는 방법이 없을것 같다.
    - 그나마 있던 분기 연산을 줄이고 단순 연산으로 치환하였다.
    - 이항연산자 형식으로 코드를 수정하는 것도 가능할듯

```java
/*
* 초중시절 도형 접기 문제에서 착안한 문제풀이.
* 반사되어 나온다는 것은 t초 동안 이동한 후에 p, q의 좌표를 기준으로 전체 지도의 높이와 너비를 기준으로
* 나머지 연산을 실시하여 이동후의 p, q의 좌표를 구할 수 있다.
*/

if((p+t) / W % 2 == 0){
    p = (p + t) % W;
} else if(((p+t) / W) % 2 == 1){
    p = W - (p + t) % W;
}

if(((q+t) / H) % 2 == 0){
    q = (q + t) % H; 
} else if(((q+t)/ H) % 2 == 1){
    q = H - (q+t) % H;
}
```

```java
/*
* t초 후의 p, q 좌표를 전체 그래프의 너비와 높이의 2배를 한 것으로 나머지 연산을 실시한다.
* 2배를 한 이유는 실제 지도의 너비 혹은 높이를 기준으로 위쪽으로 넘어가면 양수, 아래로 내려가면 음수의 값을 가지도록 하기 위함이다.
*/

p = W - Math.abs(W- (p+t) %(2*W));
q = H - Math.abs(H - (q+t)%(2*H));
```



## 진기의 최고급 붕어빵(swea_1860)

### 풀이

- 모든 시간에 대하여 반복문을 순회하며 붕어빵 개수와 손님이 찾아오는 때를 비교하자니 시간의 범위가 길었다 (0 ≤  t ≤ 11111)
- 일반 시뮬레이션 문제처럼 상황을 일반화하는 것이 중요
- 들어오는 손님의 시간을 오름차순으로 정렬하고 해당 인덱스를 활용하여 판매한 붕어빵의 개수를 파악할 수 있다.
- 이를 일반화하여 아래와 같은 반복문을 작성하였다. 조건은 만들어낸 붕어빵의 개수보다 판매한 붕어빵의 개수가 더 많을 때를 의미한다. 이러한 조건을 만족하게 되면 answer를 바꾸고 반복문을 멈춘다.

```java
for(int i = 0 ; i < N ; i++){
  if((customers[i] / M) * K < i + 1){
    answer = "Impossible";
    break;
  }
}
```